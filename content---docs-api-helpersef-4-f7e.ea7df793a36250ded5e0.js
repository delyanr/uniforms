(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{45:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return o}),a.d(n,"rightToc",function(){return s}),a.d(n,"default",function(){return d});a(0);var r=a(105);function t(){return(t=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var r in a)Object.prototype.hasOwnProperty.call(a,r)&&(e[r]=a[r])}return e}).apply(this,arguments)}function i(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var o={id:"api-helpers",title:"Helpers"},s=[{value:"changedKeys",id:"changedkeys",children:[]},{value:"connectField",id:"connectfield",children:[]},{value:"createSchemaBridge",id:"createschemabridge",children:[]},{value:"createSchemaBridge.register",id:"createschemabridgeregister",children:[]},{value:"filterDOMProps",id:"filterdomprops",children:[]},{value:"filterDOMProps.register",id:"filterdompropsregister",children:[]},{value:"filterDOMProps.registered",id:"filterdompropsregistered",children:[]},{value:"injectName",id:"injectname",children:[]},{value:"joinName",id:"joinname",children:[]},{value:"nothing",id:"nothing",children:[]},{value:"randomIds",id:"randomids",children:[]}],c={rightToc:s},l="wrapper";function d(e){var n=e.components,a=i(e,["components"]);return Object(r.b)(l,t({},c,a,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"changedkeys"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#changedkeys"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"changedKeys")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import changedKeys from 'uniforms/changedKeys';\n\n// Returns an array of changed keys between valueA and valueB, where root is the\n// root key.\nconst arrayOfChangedKeys = changedKeys(root, valueA, valueB);\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Note:")," For more examples, see ",Object(r.b)("a",t({parentName:"p"},{href:"https://github.com/vazco/uniforms/blob/master/packages/uniforms/test/helpers/changedKeys.js"}),Object(r.b)("inlineCode",{parentName:"a"},"changedKeys")," tests"),"."),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"connectfield"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#connectfield"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"connectField")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import connectField from 'uniforms/connectField';\n\nconst ComponentXField = connectField(ComponentX, {\n  // Props mapper\n  //   Useful for integration with third-party components. For example, you\n  //   can rename specific props instead of doing mapping by hand in the\n  //   component.\n  mapProps: props => props,\n\n  // Base field class\n  //   It's reserved for the future - right now there's no useful usecase.\n  baseField: BaseField,\n\n  // <input> helper\n  //   In React, <input> can't have undefined or null value and any onChange\n  //   at once - this option passes 'undefined' as en empty string.\n  ensureValue: true,\n\n  // Initial value check\n  //   If truthy, then after the first render defaultValue is set as value if\n  //   no value is provided (undefined).\n  initialValue: true,\n\n  // Additional parent prop\n  //   If truthy, additional parent prop is provided (if any). Useful for\n  //   nested or complex fields.\n  includeParent: false,\n\n  // Field name chain visibility\n  //   If truthy, then every nested field name will be prefixed with parent\n  //   name.\n  includeInChain: true\n});\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"createschemabridge"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#createschemabridge"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"createSchemaBridge")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import createSchemaBridge from 'uniforms/createSchemaBridge';\n\n// It's rather an internal helper, but it's still exported. Use it, if you want\n// to manually create a schema bridge or to test your bridge. It will throw on\n// an unrecognised schema.\nconst bridge = createSchemaBridge(schemaOrBridge);\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"createschemabridgeregister"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#createschemabridgeregister"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"createSchemaBridge"),".register"),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"// If you want to register a custom bridge.\ncreateSchemaBridge.register(propA, propB, propC /* ... */);\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"filterdomprops"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#filterdomprops"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"filterDOMProps")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import filterDOMProps from 'uniforms/filterDOMProps';\n\n// If you create your custom field, then it's a safe way to get rid of all\n// uniforms-related props.\nconst nonUniformsProps = filterDOMProps(props);\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"filterdompropsregister"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#filterdompropsregister"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"filterDOMProps"),".register"),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"// If you want to filter additional props, then you have to register it.\nfilterDOMProps.register(propA, propB, propC /* ... */);\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"filterdompropsregistered"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#filterdompropsregistered"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"filterDOMProps"),".registered"),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"// Array of already registered props.\nfilterDOMProps.registered; // ['propA', 'propB', ...]\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"injectname"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#injectname"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"injectName")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import injectName from 'uniforms/injectName';\n\n// It's rather an internal helper, but it's still exported. Injects name to all\n// already rendered fields.\nconst componentWithInjectedName = injectName(name, component);\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"joinname"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#joinname"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"joinName")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import joinName from 'uniforms/joinName';\n\n// Use it to safely join partial field names. If you create a custom field with\n// subfields, then it's better to use this helper.\nconst joinedNameString = joinName(nameA, nameB, nameC /* ... */);\n\n// If you want to have a \"raw\" version of a name, then pass null as the first\n// param.\nconst joinedNameArray = joinName(null, nameA, nameB, nameC /* ... */);\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"nothing"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#nothing"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"nothing")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import nothing from 'uniforms/nothing';\n\n// In React@0.14 you can't return null from functional component, but in\n// React@15 you should use null - nothing is a \"safe null\". Basically it's a\n// <noscript /> in @0.14 and null in @15.\nconst emptyJSX = () => nothing;\n")),Object(r.b)("h2",null,Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"randomids"})),Object(r.b)("a",t({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#randomids"}),"#"),Object(r.b)("inlineCode",{parentName:"h2"},"randomIds")),Object(r.b)("pre",null,Object(r.b)("code",t({parentName:"pre"},{className:"language-js"}),"import randomIds from 'uniforms/randomIds';\n\n// It's rather an internal helper, but it's still exported. Use it, if you want\n// to have some random but deterministic strings.\nconst predictableRandomIdGenerator = randomIds(prefix);\nconst predictableRandomIdA = predictableRandomIdGenerator();\nconst predictableRandomIdB = predictableRandomIdGenerator();\nconst predictableRandomIdC = predictableRandomIdGenerator();\n// ...\n")))}d.isMDXComponent=!0}}]);