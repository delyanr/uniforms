(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{43:function(e,a,n){"use strict";n.r(a),n.d(a,"frontMatter",function(){return i}),n.d(a,"rightToc",function(){return l}),n.d(a,"default",function(){return m});n(0);var t=n(105);function o(){return(o=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}function r(e,a){if(null==e)return{};var n,t,o=function(e,a){if(null==e)return{};var n,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(o[n]=e[n]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i={id:"api-forms",title:"Forms"},l=[{value:"AutoForm",id:"autoform",children:[]},{value:"BaseForm",id:"baseform",children:[]},{value:"QuickForm",id:"quickform",children:[]},{value:"ValidatedForm",id:"validatedform",children:[]},{value:"ValidatedQuickForm",id:"validatedquickform",children:[]}],s={rightToc:l},d="wrapper";function m(e){var a=e.components,n=r(e,["components"]);return Object(t.b)(d,o({},s,n,{components:a,mdxType:"MDXLayout"}),Object(t.b)("h2",null,Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"autoform"})),Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#autoform"}),"#"),Object(t.b)("inlineCode",{parentName:"h2"},"AutoForm")),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),"import AutoForm from 'uniforms/AutoForm'; // Or from the theme package.\n\n<AutoForm\n  // Like onChange but for the whole model.\n  //   Triggered just after onChange but with the next model instead of\n  //   (key, value) pair.\n  onChangeModel={model => console.log(model)}\n/>;\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"Note:")," All ",Object(t.b)("inlineCode",{parentName:"p"},"ValidatedQuickForm")," props are also accepted and all methods are available."),Object(t.b)("h2",null,Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"baseform"})),Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#baseform"}),"#"),Object(t.b)("inlineCode",{parentName:"h2"},"BaseForm")),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),"import BaseForm from 'uniforms/BaseForm'; // Or from the theme package.\n\n<BaseForm\n  // Autosave delay.\n  //   Set 0 for an instant autosave.\n  autosaveDelay={0}\n  // Enable autosave.\n  //   Every change triggers onSubmit.\n  autosave={false}\n  // Disable form.\n  //   Disables all fields and submit button.\n  disabled={false}\n  // Validation error.\n  //   Current validation state. It should be either compatible with your\n  //   schema or an Error object.\n  error={new Error('Nope.')}\n  // Form layout.\n  //   Bootstrap grid layout style. Number is an equivalent of {sm: n}. Object\n  //   is a {mode: size} object. Complete string is simply passed through.\n  // Available in:\n  //   bootstrap3\n  //   bootstrap4\n  grid={3} // 'col-3-sm' on label, 'col-9-sm' on input\n  grid=\"4\" // 'col-4-sm' on label, 'col-8-sm' on input\n  grid={{md: 5}} // 'col-5-md' on label, 'col-7-md' on input\n  grid=\"col-6-xl\" // 'col-6-xl' on label, 'col-6-xl' on input\n  // Default label prop for all fields.\n  //   By default it's true - set it to false to disable labels for the whole\n  //   form.\n  label={true}\n  // Form model.\n  //   An object with {field: value} structure. It doesn't matter, if it has a\n  //   prototype or not, but keep in mind that in onSubmit or in onChangeModel\n  //   you'll receive a plain object. If you treat form as an input, then\n  //   this is a value.\n  model={{fieldA: 1}}\n  // Model transform.\n  //   Function transforming one model into another. It's used in few\n  //   situations (modes) described below. Do not mutate a given model!\n  modelTransform={(mode, model) => {\n    // This model will be passed to the fields.\n    if (mode === 'form') {\n      /* ... */\n    }\n\n    // This model will be submitted.\n    if (mode === 'submit') {\n      /* ... */\n    }\n\n    // This model will be validated.\n    if (mode === 'validate') {\n      /* ... */\n    }\n\n    // Otherwise, return unaltered model.\n    return model;\n  }}\n  // Field change action.\n  //   It receive two arguments: key and value, where key is a dot separated\n  //   path to the changed field and value is a requested value.\n  onChange={(key, value) => console.log(key, value)}\n  // Submit failure action.\n  //   If onSubmit returns a Promise, then this will be attached to its\n  //   .catch chain.\n  onSubmitFailure={() => alert('Promise rejected!')}\n  // Submit success action.\n  //   If onSubmit returns a Promise, then this will be attached to its\n  //   .then chain.\n  onSubmitSuccess={() => alert('Promise resolved!')}\n  // Submit action.\n  //   When the form is submitted manually or by a HTML5 event, then it's\n  //   called with the current model.\n  onSubmit={model => db.saveThatReturnsPromiseOrNothing(model)}\n  // Default placeholder prop for all fields.\n  //   By default it's false - set it to true to enable placeholders for the\n  //   whole form.\n  placeholder={false}\n  // Form schema.\n  //   BaseForm doesn't really care about it. It's used for form generation in\n  //   QuickForm and validation in ValidatedForm.\n  schema={myFormSchema}\n  // Default showInlineError prop for all fields.\n  //   By default it's false - set it to true to enable inline errors for the\n  //   whole form.\n  // Available in:\n  //   antd\n  //   bootstrap3\n  //   bootstrap4\n  //   semantic\n  showInlineError={true}\n  // Form methods.\n  ref={form => {\n    // Reset form.\n    //   It will reset changed state, model state in AutoForm, validation\n    //   state in ValidatedForm and rerender.\n    form.reset();\n\n    // Trigger form change.\n    //   It's a programatic equivalent of a change event.\n    form.change(key, value);\n\n    // Submit form.\n    //   It's a programatic equivalent of a submit event. Returns a promise,\n    //   which will either resolve with submitted form or reject with\n    //   validation error in ValidatedForm. You can also use onSubmitFailure\n    //   and onSubmitSuccess instead of doing form.submit().then().\n    form.submit();\n  }}\n/>;\n")),Object(t.b)("h2",null,Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"quickform"})),Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#quickform"}),"#"),Object(t.b)("inlineCode",{parentName:"h2"},"QuickForm")),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),"import QuickForm from 'uniforms/QuickForm'; // Or from the theme package.\n\n<QuickForm\n  // Custom AutoField.\n  //   It should be anything that will pass through React.createElement.\n  autoField={CustomAutoField}\n  // Custom ErrorsField.\n  //   It should be anything that will pass through React.createElement.\n  errorsField={CustomErrorsField}\n  // Custom SubmitField.\n  //   It should be anything that will pass through React.createElement.\n  submitField={CustomSubmitField}\n/>;\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"Note:")," All ",Object(t.b)("inlineCode",{parentName:"p"},"BaseForm")," props are also accepted and all methods are available."),Object(t.b)("h2",null,Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"validatedform"})),Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#validatedform"}),"#"),Object(t.b)("inlineCode",{parentName:"h2"},"ValidatedForm")),Object(t.b)("pre",null,Object(t.b)("code",o({parentName:"pre"},{className:"language-js"}),"import ValidatedForm from 'uniforms/ValidatedForm'; // Or from the theme package.\n\n<ValidatedForm\n  // Additional asynchronous validation.\n  //   Schema validation has to be sync, so this is the only way to achieve\n  //   async validation.\n  onValidate={(model, error, callback) => {\n    // You can either ignore validation error...\n    if (omitValidation(model)) {\n      return callback(null);\n    }\n\n    // ...or any additional validation if an error is already there...\n    if (error) {\n      return callback();\n    }\n\n    // ...or feed it with another error.\n    MyAPI.validate(model, error => callback(error || null));\n  }}\n  // Validation mode.\n  //   By default, the form will start to validate from the time of the first\n  //   submit and then revalidate on every change. It's 'onChangeAfterSubmit'.\n  //   There are also 'onChange' and 'onSubmit' modes, but those are quite\n  //   self-explanatory.\n  validate=\"onChangeAfterSubmit\"\n  // Validator options.\n  //   It's passed to getValidator of your schema bridge. It really depends on\n  //   your schema.\n  validator={{clean: true}}\n  // Form methods.\n  ref={form => {\n    // Validate form with the current model.\n    //   Returns a Promise, which rejects with an validation error or\n    //   resolves without any value. Note, that it resolves/rejects AFTER\n    //   the component is rerendered.\n    form.validate();\n\n    // Validate form with key set to value.\n    //   You can use it to check, if a given value will pass the\n    //   validation or not. Returns validation Promise, as described above.\n    form.validate(key, value);\n\n    // Validate form with the given model.\n    //   Rather internal function. Returns validation Promise, as described\n    //   above.\n    form.validateModel(model);\n  }}\n/>;\n")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"Note:")," All ",Object(t.b)("inlineCode",{parentName:"p"},"BaseForm")," props are also accepted and all methods are available."),Object(t.b)("h2",null,Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"validatedquickform"})),Object(t.b)("a",o({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#validatedquickform"}),"#"),Object(t.b)("inlineCode",{parentName:"h2"},"ValidatedQuickForm")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"Note:")," All ",Object(t.b)("inlineCode",{parentName:"p"},"QuickForm")," props are also accepted and all methods are available.",Object(t.b)("br",null),"\n",Object(t.b)("strong",{parentName:"p"},"Note:")," All ",Object(t.b)("inlineCode",{parentName:"p"},"ValidatedForm")," props are also accepted and all methods are available."))}m.isMDXComponent=!0}}]);