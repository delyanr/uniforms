(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{57:function(e,n,a){"use strict";a.r(n),a.d(n,"frontMatter",function(){return o}),a.d(n,"rightToc",function(){return l}),a.d(n,"default",function(){return c});a(0);var t=a(105);function i(){return(i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var a=arguments[n];for(var t in a)Object.prototype.hasOwnProperty.call(a,t)&&(e[t]=a[t])}return e}).apply(this,arguments)}function r(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o={id:"examples",title:"Examples"},l=[{value:"Bridges",id:"bridges",children:[{value:"MyLittleSchema",id:"mylittleschema",children:[]}]},{value:"Fields",id:"fields",children:[{value:"CompositeField",id:"compositefield",children:[]},{value:"CustomAutoField",id:"customautofield",children:[]},{value:"CycleField",id:"cyclefield",children:[]},{value:"DisplayIf",id:"displayif",children:[]},{value:"RangeField",id:"rangefield",children:[]},{value:"RatingField",id:"ratingfield",children:[]},{value:"SubmitButton",id:"submitbutton",children:[]},{value:"SwapField",id:"swapfield",children:[]}]},{value:"Forms",id:"forms",children:[{value:"ModifierForm",id:"modifierform",children:[]}]}],s={rightToc:l},d="wrapper";function c(e){var n=e.components,a=r(e,["components"]);return Object(t.b)(d,i({},s,a,{components:n,mdxType:"MDXLayout"}),Object(t.b)("h2",null,Object(t.b)("a",i({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"bridges"})),Object(t.b)("a",i({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#bridges"}),"#"),"Bridges"),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"mylittleschema"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#mylittleschema"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"MyLittleSchema")),Object(t.b)("p",null,Object(t.b)("strong",{parentName:"p"},"Note:")," This is a very basic schema just to show how it works and how you can create your own schema bridges."),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import Bridge from 'uniforms/Bridge';\n\nclass MyLittleSchema extends Bridge {\n  constructor(schema, validator) {\n    super();\n\n    this.schema = schema;\n    this.validator = validator;\n  }\n\n  getError(name, error) {\n    return error && error[name];\n  }\n\n  getErrorMessage(name, error) {\n    return error && error[name];\n  }\n\n  getErrorMessages(error) {\n    return error ? Object.keys(this.schema).map(field => error[field]) : [];\n  }\n\n  getField(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')];\n  }\n\n  getType(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')].__type__;\n  }\n\n  getProps(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')];\n  }\n\n  getInitialValue(name) {\n    return this.schema[name.replace(/\\.\\d+/g, '.$')].initialValue;\n  }\n\n  getSubfields(name) {\n    return name\n      ? this.schema[name.replace(/\\.\\d+/g, '.$')].subfields || []\n      : Object.keys(this.schema).filter(field => field.indexOf('.') === -1);\n  }\n\n  getValidator() {\n    return this.validator;\n  }\n}\n\n// Usage.\nconst bridge = new MyLittleSchema(\n  {\n    login: {\n      __type__: String,\n      required: true,\n      initialValue: '',\n      label: 'Login'\n    },\n    password1: {\n      __type__: String,\n      required: true,\n      initialValue: '',\n      label: 'Password'\n    },\n    password2: {\n      __type__: String,\n      required: true,\n      initialValue: '',\n      label: 'Password (again)'\n    }\n  },\n  model => {\n    const error = {};\n\n    if (!model.login) {\n      error.login = 'Login is required!';\n    } else if (model.login.length < 5) {\n      error.login = 'Login has to be at least 5 characters long!';\n    }\n\n    if (!model.password1) {\n      error.password1 = 'Password is required!';\n    } else if (model.password1.length < 10) {\n      error.login = 'Password has to be at least 10 characters long!';\n    }\n\n    if (model.password1 !== model.password2) {\n      error.password1 = 'Passwords mismatch!';\n    }\n\n    if (Object.keys(error).length) {\n      throw error;\n    }\n  }\n);\n\n<AutoForm schema={bridge} />;\n")),Object(t.b)("h2",null,Object(t.b)("a",i({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"fields"})),Object(t.b)("a",i({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#fields"}),"#"),"Fields"),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"compositefield"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#compositefield"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"CompositeField")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import AutoField from 'uniforms/AutoField';\nimport React from 'react';\nimport connectField from 'uniforms/connectField';\n\n// This field is a kind of a shortcut for few fields. You can also access all\n// field props here, like value or onChange for some extra logic.\nconst Composite = () => (\n  <section>\n    <AutoField field=\"firstName\" />\n    <AutoField field=\"lastName\" />\n    <AutoField field=\"age\" />\n  </section>\n);\n\nconst CompositeField = connectField(Composite);\n")),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"customautofield"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#customautofield"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"CustomAutoField")),Object(t.b)("p",null,"These are two ",Object(t.b)("em",{parentName:"p"},"standard")," options to define a custom ",Object(t.b)("inlineCode",{parentName:"p"},"AutoField"),": either using ",Object(t.b)("inlineCode",{parentName:"p"},"connectField")," or simply taking the code from the ",Object(t.b)("a",i({parentName:"p"},{href:"https://github.com/vazco/uniforms/blob/master/packages/uniforms-unstyled/src/AutoField.js#L14-L47"}),"original one")," ",Object(t.b)("em",{parentName:"p"},"(theme doesn't matter)")," and simply apply own components and/or rules to render components. Below an example with ",Object(t.b)("inlineCode",{parentName:"p"},"connectField"),"."),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"// Remember to choose a correct theme package\nimport AutoField from 'uniforms-unstyled/AutoField';\n\nconst CustomAuto = props => {\n  // This way we don't care about unhandled cases - we use default\n  // AutoField as a fallback component.\n  const Component = determineComponentFromProps(props) || AutoField;\n\n  return <Component {...props} />;\n};\n\nconst CustomAutoField = connectField(CustomAuto, {\n  ensureValue: false,\n  includeInChain: false,\n  initialValue: false\n});\n\n// You can also tell your `AutoForm`/`QuickForm`/`ValidatedQuickForm` to use it.\n<AutoForm {...props} autoField={CustomAutoField} />;\n")),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"cyclefield"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#cyclefield"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"CycleField")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import React from 'react';\nimport classnames from 'classnames';\nimport connectField from 'uniforms/connectField';\n\n// This field works as follows: iterate all allowed values and optionally no-value\n// state if the field is not required. This one uses Semantic-UI.\nconst Cycle = ({allowedValues, label, required, value, onChange}) => (\n  <a\n    className={classnames('ui', !value && 'basic', 'label')}\n    onClick={() =>\n      onChange(\n        value\n          ? allowedValues.indexOf(value) === allowedValues.length - 1\n            ? required\n              ? allowedValues[0]\n              : null\n            : allowedValues[allowedValues.indexOf(value) + 1]\n          : allowedValues[0]\n      )\n    }\n  >\n    {value || label}\n  </a>\n);\n\nconst CycleField = connectField(Cycle);\n")),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"displayif"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#displayif"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"DisplayIf")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import BaseField from 'uniforms/BaseField';\nimport nothing from 'uniforms/nothing';\nimport {Children} from 'react';\n\n// We have to ensure that there's only one child, because returning an array\n// from a component is prohibited.\nconst DisplayIf = ({children, condition}, {uniforms}) => (condition(uniforms) ? Children.only(children) : nothing);\nDisplayIf.contextTypes = BaseField.contextTypes;\n\n// Usage.\nconst ThreeStepForm = ({schema}) => (\n  <AutoForm schema={schema}>\n    <TextField name=\"fieldA\" />\n\n    <DisplayIf condition={context => context.model.fieldA}>\n      <section>\n        <TextField name=\"fieldB\" />\n\n        <DisplayIf condition={context => context.model.fieldB}>\n          <span>Well done!</span>\n        </DisplayIf>\n      </section>\n    </DisplayIf>\n  </AutoForm>\n);\n")),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"rangefield"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#rangefield"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"RangeField")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import React from 'react';\nimport connectField from 'uniforms/connectField';\n\n// This field works as follows: two datepickers are bound to each other. Value is\n// a {start, stop} object.\nconst Range = ({onChange, value: {start, stop}}) => (\n  <section>\n    <DatePicker max={stop} value={start} onChange={start => onChange(start, stop)} />\n    <DatePicker min={start} value={stop} onChange={stop => onChange(start, stop)} />\n  </section>\n);\n\nconst RangeField = connectField(Range);\n")),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"ratingfield"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#ratingfield"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"RatingField")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import React from 'react';\nimport classnames from 'classnames';\nimport connectField from 'uniforms/connectField';\n\n// This field works as follows: render stars for each rating and mark them as\n// filled, if rating (value) is greater. This one uses Semantic-UI.\nconst Rating = ({className, disabled, max = 5, required, value, onChange}) => (\n  <section className={classnames('ui', {disabled, required}, className, 'rating')}>\n    {[...Array(max)]\n      .map((_, index) => index + 1)\n      .map(index => (\n        <i\n          key={index}\n          className={classnames(index <= value && 'active', 'icon')}\n          onClick={() => disabled || onChange(!required && value === index ? null : index)}\n        />\n      ))}\n  </section>\n);\n\nconst RatingField = connectField(Rating);\n")),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"submitbutton"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#submitbutton"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"SubmitButton")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import BaseField from 'uniforms/BaseField';\nimport React from 'react';\n\n// This field works as follows: render standard submit field and disable it, when\n// the form is invalid. It's a simplified version of a default SubmitField from\n// uniforms-unstyled.\nconst SubmitField = (\n  props,\n  {\n    uniforms: {\n      error,\n      state: {disabled, submitting, validating}\n    }\n  }\n) => <input disabled={!!(error || disabled || submitting || validating)} type=\"submit\" />;\n\nSubmitField.contextTypes = BaseField.contextTypes;\n")),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"swapfield"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#swapfield"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"SwapField")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),'import BaseField from \'uniforms/BaseField\';\nimport get from \'lodash/get\';\nimport {Children} from \'react\';\nimport {cloneElement} from \'react\';\n\n// This field works as follows: on click of its child it swaps values of fieldA\n// and fieldB. It\'s that simple.\nconst SwapField = ({children, fieldA, fieldB}, {uniforms: {model, onChange}}) =>\n  cloneElement(Children.only(children), {\n    onClick() {\n      const valueA = get(model, fieldA);\n      const valueB = get(model, fieldB);\n\n      onChange(fieldA, valueB);\n      onChange(fieldB, valueA);\n    }\n  });\n\nSwapField.contextTypes = BaseField.contextTypes;\n\n// Usage.\nfunction Example() {\n  return (\n    <section>\n      <TextField name="firstName" />\n      <SwapField fieldA="firstName" fieldB="lastName">\n        <Icon name="refresh" />\n      </SwapField>\n      <TextField name="lastName" />\n    </section>\n  );\n}\n')),Object(t.b)("h2",null,Object(t.b)("a",i({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"forms"})),Object(t.b)("a",i({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#forms"}),"#"),"Forms"),Object(t.b)("h3",null,Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"modifierform"})),Object(t.b)("a",i({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#modifierform"}),"#"),Object(t.b)("inlineCode",{parentName:"h3"},"ModifierForm")),Object(t.b)("pre",null,Object(t.b)("code",i({parentName:"pre"},{className:"language-js"}),"import BaseForm from 'uniforms/BaseForm';\n\n// In uniforms, every form is just an injectable set of functionalities. Thus,\n// we can live without many higher order components, using composed ones\n// instead. If you want to get a deeper dive into it, read the source of\n// AutoForm or QuickForm in the core package.\nconst Modifier = parent =>\n  class extends parent {\n    // Expose injector.\n    //   It's not required, but recommended.\n    static Modifier = Modifier;\n\n    // Alter component display name.\n    //   It's not required, but recommended.\n    static displayName = `Modifier${parent.displayName}`;\n\n    // Here you can override any form methods or create additional ones.\n    getModel(mode) {\n      if (mode === 'submit') {\n        const doc = super.getModel('submit');\n        const keys = this.getChildContextSchema().getSubfields();\n\n        const update = keys.filter(key => doc[key] !== undefined);\n        const remove = keys.filter(key => doc[key] === undefined);\n\n        // It's a good idea to omit empty modifiers.\n        const $set = update.reduce((acc, key) => ({...acc, [key]: doc[key]}), {});\n        const $unset = remove.reduce((acc, key) => ({...acc, [key]: ''}), {});\n\n        return {$set, $unset};\n      }\n\n      return super.getModel(mode);\n    }\n  };\n\n// Now we have to inject our functionality. This one is a ModifierForm. Use any\n// form component you want.\nconst ModifierForm = Modifier(BaseForm);\n")))}c.isMDXComponent=!0}}]);